

	 
       

So far as programming goes, I'm now expanding my  urlLink Encryption  program, into Encryption 0.3. As of current, I'm debugging my new algorithm I want to implement. Emboldened by my "success" with Encryption 0.2, I took the entire README file and encrypted it. Whoa. Then I encrypted it back. One fundamental problem with the way the 0.2 algorithm worked was that it didn't support carriage returns or tabs. The result was that when I converted it back, everywhere in which a carriage return was supposed to be, I found only a black rectangle that looks something like "[]". That little character is what I recognize to be a marker for a carriage return, but also for exotic characters that Notepad (or Windows even) doesn't recognize. 
 
So in this iteration of Justin's programming, I tried to add support for backspaces and carriage returns. As you can see, however, this proves to be a little different. Take a look at the  urlLink ASCII table . For many of you, you don't give a crap about my algorithms, so bear with me. The 0.2 algorithm goes from numbers 32-126, inclusive. But Tab and carriage return are numbers 9 and 13. There's no easy way to cycle through that. My current solution is to create generic numbers 30 and 31 to represent 9 and 13. Then, when the algorithms decrypting, if the numbers are 30 and 31, it'll reassign them to 9 and 13. Currently I'm having trouble getting all this right, but I'm sure that once I crack it, I'm done with the hardest part. 
 
So really, my "new" algorithm isn't really new, per se, it's just an expansion of the old one to make it more complex. This new one also uses the extended ASCII set, but not all the way because those wonky symbols probably won't show up in Notepad, anyway (although I do know for a fact it it  will  show up in cmd.exe. I noticed that while debugging the 0.2 algorithm and I kept on getting those weird characters). For your information, it goes up to 165 ('') 
 
After that, I also want to add greater functionality to it, by adding options, after the encryption (or decryption), to see if the user wants to print the document out (with confirmation prompt), or view it (no confirmation prompt), without having to leave the program. Also, I want it to be completely bulletproof. Error checking will be everywhere and anywhere something could, in the name of god, go wrong. I won't add a GUI. I don't think I'll fix that bug where after decryption, there are a bunch of random letters still. That error I was aware of, but gave up on trying to fix, while working on 0.2. It's caused by how the password is still iteration, and adding itself to the file's characters, even if I've already eached the end of the document. It's just the way the relationship is between the inner loop (add password) and the outer loop (end of document). The last thing I want to do is to add two more menu options to the main menu. Rather than having "any other key to quit," I want to just have menu option 4, "Exit" (with confirmation prompt). Also, I want to have a menu option 3, "About" or "Read This" or something like that. It will contain the entire README, as well as the history (and other information) of cryptography, how the algorithm works, as well as some words by me about the making of the program. It's a bit extreme for something so stupid, but I'm very anal about being professional. 
 
More about being anal. In the Encryption 0.2, I had intended on having the README for the Light Edition to NOT have the part about the included source code, but for some reason, it was. Also, the way it extracted, it put the README and the program folder in the directory, which I found annoying, which I'll have to fix. 
Of course, I will include all the algorithms, with my test executables as well as the source code to them all. Also, I discovered that my password masking executable was rather fruitless. It was a nice example, but I'll modify it so that it has a better purpose. 
Okay,  this  is the last thing I'll tell you about what I want to do with encryption next. I want to format the entire code so that it adopts to Justin's latest code standards. I switched to monospace font, so the code that I wrote with my previous sans-serif font now goes past the page. I don't actually plan on fixing the horizontal space, because it's acceptable. The only thing that really go past are comments and long paragraphs (like Annoying Notice 1  2). Yes. It  is  very easy to get lost in that sea of black, blue, and green (for me, it's mostly green [smile]). That's why the reformatting is necessary. So basically, I'll just be fixing the formatting. For example, if there aren't any parameters, then there's no space between the function name and the parameter list, but otherwise there is. Also, I'll be working with alignments because I like seeing everything in neat little columns. I talked about this before, but it was a long post, and so I won't link to it. Was it a long post? I don't remember. But basically I want to clean up the code. The last thing you want to be doing, especially when your brain is hard at work on some problem, is for your brain to have to devote resources to trying to figure out what you really are doing. 
 
Once I finish this, I will move back into the foray of creating games. At first, it'll be very simple. The first thing is to write my tic-tac-toe heurstic. Then my rock-paper-scissors heurstic. Then, I will move into OpenGL and attack via the space shooter clone. 
 
That is my plan. 
 
-- justin

 
    
