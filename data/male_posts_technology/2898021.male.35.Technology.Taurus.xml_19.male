

    
       
        # A Demo for computing Polynomial. # (C) 2004, Muhammad Lutfi  # ------------ poly.h -----------------------  #ifndef POLYNOM_H #define POLYNOM_H  #define MAX_POLYNOM_ELEMENTS     250  typedef struct {    int coef;    int pow_x;    int pow_y; } PType;  typedef struct {    int     n;    PType    *poly;    //POLYNOM     *next; } POLYNOM;  typedef struct {    POLYNOM        *prev;    POLYNOM        polynom;    POLYNOM        *next; } POLYNOMLIST;   #endif # ------------------ end of poly.h ----------------------------  #------- poly.c ------------------ #include   #include   #include   #include "poly.h"  const char *delim = " ";  int Polynom_GetInput(POLYNOM *plnm) {    char buf[1024];    int i,j,n;    div_t divr;    char *p;    int a[3*MAX_POLYNOM_ELEMENTS];      //printf("Enter your polynomial variables (it is sequence of triples: c pow_x pow_y)\n");    printf("Enter Polynoms = ");    gets(buf);    if (strlen(buf) == 0) {        plnm->n = 0;        plnm->poly = NULL;        return 0;    }    n = 0;    if ((p=strtok(buf, delim)) != NULL) {        // found the first input        n=1;        a[0] = atoi(p);    }    while ((p=strtok(NULL, delim)) != NULL  n  0) {        /* that's all the input.  Now, ensure the input is repetition of triplets        */        divr = div(n,3);        if (divr.rem == 0) {        // yes, it is a sequence of triplet            plnm->poly = (PType*)malloc(n/3 * sizeof(PType));            if (plnm->poly == NULL)                exit(1);            plnm->n = n/3;            for(i=0; i  poly[j].coef = a[i];                    plnm->poly[j].pow_x = a[i+1];                    plnm->poly[j].pow_y = a[i+2];                }            }            return 1;        }    }    return 0; }  int Polynom_Copy(const POLYNOM *src, POLYNOM *dest) {    // destination polynom should not NULL    if (src==NULL || dest==NULL) return 0;    dest->poly = (PType *)malloc(src->n * sizeof(PType));    if (dest->poly) {        memcpy(dest->poly, src->poly, src->n * sizeof(PType));        return 1;    }    return 0; }   void Polynom_Free(POLYNOM *p) {    if (!p) return;    if (p->poly) {        free(p->poly);        p->n = 0;        p->poly = NULL;    } }   void Polynom_Print(const POLYNOM *p) {    int i;    char strc[50], strx[50], stry[50];    short sign;    char strsign[5];    short first_time=1;    int coef;      if (!p) return;    strx[0] = '\0';    stry[0] = '\0';    for(i=0; i n; i++) {        coef = p->poly[i].coef;        // ignore coef=0        // using temporary var for sign is slightly faster than accessing structure of pointer p        if (coef != 0) {            sign = ( coef  poly[i].pow_x !=0 || p->poly[i].pow_y !=0))                strcpy(strc, strsign);            else                sprintf(strc, "%s%0d", strsign, abs(coef));            if (p->poly[i].pow_x == 0)                strcpy(strx, "");            else if (p->poly[i].pow_x == 1)                strcpy(strx, "x");            else                sprintf(strx, "x^%-d", p->poly[i].pow_x);            if (p->poly[i].pow_y == 0)                strcpy(stry, "");            else if (p->poly[i].pow_y == 1)                strcpy(stry, "y");            else                sprintf(stry, "y^%-d", p->poly[i].pow_y);            //sprintf("%u%s%s");            printf("%s%s%s", strc, strx, stry);        }    }    printf("\n"); }   int Polynom_Add(PType *result, const PType P1, const PType P2) {    if (result == NULL)        return 0;    if ((P1.pow_x == P2.pow_x)  (P1.pow_y == P2.pow_y)) {        // p1  p2 have the same order of x,y        result->coef = P1.coef + P2.coef;        return 1;      }    else {        return 0;    } }  void Polynom_Simplify(POLYNOM *p1, POLYNOM *p2) {    int i,j,k;     }   int main(int argc, char *argv[]) {    POLYNOM p1;    int i=0;      while (Polynom_GetInput()) {        //for(i=0; i         
       
    
    
