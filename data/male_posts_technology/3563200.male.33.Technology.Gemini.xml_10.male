

	 
      Any modern software application that doesn't serialize data to XML at least to some degree isn't very forward thinking (what good is your data 50 years from now?) or is intentionally being proprietary (nothing wrong with that). Now that almost every modern development platform supports XML it's easy to accomplish serialization to an easy-to-parse, human-readable format (with built-in schema info. if you wish). But don't rely on your nearest class-library if your application is going to have to persist (pun intended) for any duration, be used by early and late adopters, or have more than one version deployed as time passes. You can't always take this easy path:   Stream stream = File.Open(sFileName, FileMode.Create); SoapFormatter formatter = new SoapFormatter(); formatter.Serialize(stream, SomeObject); stream.Close();   The SoapFormatter is GREAT for introspecting your class and XMLifying it. And although the XML produced is fatter, by necessity, than that produced by the vanilla XML serializer, the SoapFormatter can get at protected members and doesn't require a public default constructor.  But as we stand on the shoulders of giants, let's not forget our parachute. In other words: this approach is 'misleadingly' easy because if you ever have to make changes to your object (like in a later version when you add new members) the SoapFormatter will refuse to load your file and throw an exception like this:   System.Runtime.Serialization.SerializationException : Wrong number of Members. Object SomeObject has 9 members, number of members deserialized is 8.   This is a similar predicament you could get into with MFC's CArchive mechanism which took care of persisting data to a binary format. All was fine and dandy until you had to make changes to what you were persisting, then you essentially broke backwards compatibility with older files.  To make a proper application, you ended up having to write your own persistence mechanism to take versioning into account. After all, any application that doesn't open files that previous versions created sucks. What if Word 2003 couldn't open Word 95 documents?  So what's my rant? Well having to write your own persistence mechanism to take versioning into account in this day and age is a pain. With all the thought that's gone into object serialization from Java RMI to SOAP, why hasn't someone addressed object versioning?  If anyone out there has some answers and wants to prevent me from reinventing a really old wheel, please  urlLink email me .  In the meantime, I'm writing my own serialization system (again) just in a different language that actually supports backwards compatibility within my application and doesn't throw exceptions when poor users try to load an older file...geesh...it's 2004 for crying out loud!  Can someone ask Don Box to please think about this?  -Bruce 
     
    
