

     
      WordIQ defines a "Software Engineering" as the profession concerned with the creation and maintenance of software applications by APPLYING Computer Science, Project Management, Domain Knowledge and other skills and technologies. It is not enough to just write efficient, bug free programs to be a Software Engineer. A software engineer in the true sense should be able to unify programming knowledge (which should serve no more than as tools), with a comprehensive body of knowledge on Computer Science, Mathematics, and many other areas and apply suitable Project Management Techniques to make sure the development is effective. In some specialized areas, such as Medical Imaging, Biotechnology (which are emerging areas today), he/she needs to acquire domain knowledge, translate that into tools which can be used by already skilled people in those domains in order to help them improve their abilities and productivity.  A programmer on the other hand just needs to churn out code.  When I say that a software engineer should consider programming languages and related technologies as tools, I do not mean that one should ignore them. He/she has to know the tools that he/she needs to work with. Knowledge of the tools can help him decide which one is best suited for the job. The old adage says productivity = (skills)^tools, so tools are an extremely important aspect of developing software, something that can improve performance exponentially.  However, there needs to be note of caution. Learning a new tool takes time, and overall usage matures over time. So I do not think it very wise to jump in and learn every new tool that you come across. One should definitely not do it just for learnability's sake. If you feel you have all the tools at your disposal, please use them, instead of trying to master something new, just because its news (and somehow better, they all claim they are!)  There is indeed another caveat that software engineers fall into. Its called PROCESS. There are invariably too many "process gurus" within a company, each with their own very strong belief about which process is correct. A process should be tailored to the kind of development you need to have, which to some extent should depend on how fluid your development is going to be over time and what your customer expects. (If he expects, for example frequent releases, or for example is evaluating a product before purchasing is very vocal in pointing out bugs, the a continuous integration process would be quite suitable. For more control-based organizations, where there needs to be strict control on the features a product needs to have, or there is a huge separation between the analysts and developers, something like a waterfall would be more suitable. (I only provide examples, I do not want a flurry of angry emails suggesting which process is better for what!! :) ). For many companies, the process model followed by them (and as accredited by certifications) proves as a benchmark for customers as to how healthy the development within the organization is. For such companies, having these processes does make sense.  But one seldom remembers, both the above are only accessories. The customer does not care about anything other than the features the product has and how good the support is. In my opinion, one should try and stay as fluid as possible. I don't remember anybody gaining anything by having heavyweight processes in place.  The core job of a software engineer in my opinion is to bridge the gap between technology and a customer's requirement. The customer, many a times, will not know that he has a requirement! Sometimes, the software engineer will be as much a contributor to requirements as the customer himself, and that is, in my opinion, the healthy way of developing software. Sometimes a customer may think a problem unsolvable, which happens often in the image processing space, for example, but on interfacing with a software engineer, may discover infact that it is.
     
    
