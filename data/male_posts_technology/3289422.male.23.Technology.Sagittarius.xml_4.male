

	 
      The Perl Cheatsheet A quick reference on the Perl programming language By Louis P. Tychonievich  Data Types  Scalars  Numbers Strings  Special Chars String/Number Conversion  References  Arrays Hashes  Regular Expressions  Matching Substitution Simple Patterns Repeating Patterns Extraction Patterns Anchor Patterns  Files  File I/O File Attributes File Management Databases  General  Flow Control Functions Process Management Environment Settings Miscellaneous  Data Types Scalars      * $var -» scalar = number, string, or reference     * undef -» acts like 0 or "", initial value     * defined($var) -» true if not undef     * false is 0, "0", "", or undef     * not, and, or, xor   Numbers      * 123, 0xff, 0377, 1.23e-3     * numbers stored as float     * use integer; -» numbers stored as int     * +, -, *, /, ++, -, =+, =-, =*, =/     * ** (exponential), **=     * % (modulus), %=     * ==, !=,  ,  =,       * $num   $num -» -1, 0, or 1     * abs, int, sin, cos, atan2, sqrt, exp, log     * int(3.7) -» 3     * atan2(y, x) -» arctan(y/x)     * time -» seconds since Jan 1, 1970     * ($sec, $min, $hr, $day, $min, $yr, $wk, $jul, $dls) = localtime(time);     * rand -» random float in {0, 1}     * srand 123 -» seed random with 123   Strings      * "text$var" -» contents of var     * "text${var}text" -» if alpha after var     * "ab" . "dc" -» "abcd"     * $var .= "z" -» $var = $var ."z"     * 'A' x 3 -» 'AAA'     * eq, ne, lt, gt, le, ge     * 2      * "a" ne "b", but "a" == "b"     * $text cmp $text -» -1, 0, or 1     * chomp($var) -» removes last newline     * length($str) -» length of str     * substr($str,$start,$len) - also neg     * index($str, $substr, $offset)     * rindex($str, $substr, $offset)     * uc($str) -» uppercase     * lc($str) -» lowercase     * ucfirst($str) -» uppercase 1st     * lcfirst($str) -» lowercase 1st     * quotemeta($str) -» no meta chars   Special Chars      * 'text' -» literal text except \' and \    * "text" -» special chars executed     * q/text/ -» use / for '     * qq/text/ -» use / for "     * \n -» newline     * \r -» return     * \t -» tab     * \f -» formfeed     * \007 -» octal     * \xff -» hex     * \cC -» control C     * \" -» "     * \\ -»     * \l -» lowercase next     * \u -» uppercase next     * \L -» lowercase all     * \U -» uppercase all     * \E -» end all     * + * ? . ^ $ @ % ( ) [ ] { } | \   String/Number Conversion As number:      * "12" -» 12     * " 12ab" -» 12     * "ab" -» 0     * undef -» 0   As string:      * 12 -» "12"     * undef -» ""   References      * $rs = \$s -» ref to scalar     * $ra = \@a -» ref to array     * $rh = \$h -» ref to hash     * $ra = \"a" -» ref to const     * $$rs -» deref ref to scalar     * @$ra -» deref ref to array     * %$rh -» deref ref to hash     * $ra->[2] -» $$ra[2]     * $rh->{key} -» $$rh{key}     * $ra = [] -» allocate new array     * $rh = {} -» allocate new hash     * $rc = \ -» ref to subroutine     * $rc = sub{body}; -» ref to code block     * $rc(a, b) -» call func ref     * ref($var) -» 'SCALAR', 'ARRAY', 'HASH', 'REF', 'GLOB', 'CODE', or undef   Arrays      * @arr -» array of scalars     * $arr[i] -» i'th item in array, 0-based     * (1, $two, 3) -» literal array     * @arr = ( ) -» clear arr     * $len = @arr -» length of arr     * ($a) = @arr -» first element     * @arr = 2 -» @arr = (2)     * @arr1 = @arr2 -» copies array     * (1..3) -» (1, 2, 3)     * qw(Cat Dog) -» ("Cat", "Dog")     * ($a, $b) = (1, 2) -» $a = 1; $b = 2     * ($a, @arr)=(1,2) -» $a=1; @arr=(2)     * @arr[-1] -» last element of array     * @arr[-2] -» second to last element     * push(@arr, 1) -» pushes on end     * $a = pop(@arr) -» pops from end     * unshift(@arr, 1) -» pushes on front     * $a = shift(@arr) -» pops from front     * join(":", ("a", "b", "c")) -» "a:b:c"     * split(":", "a:b:c") -» ("a", "b", "c")     * splice(@arr, $start, $len) -» substr     * reverse(@arr) -» reverse order copy     * sort(@arr) -» copy sorted as text     * sort {$a   $b} @arr -» as nums     * @arr[0][0] = 3 -» access 2 dim array     * @arr = ([0, 1], [10, 11]) -» init 2 dim   Hashes      * %hash -» hash of scalars by strings     * $hash{key} = val -» set val at key     * $hash{key} -» value at key or undef     * %hash = (key => val, key => val)     * %hash=(a, b, c, d) -» (a => b, c => d)     * @arr = %hash -» list of pairs     * %hash1 = %hash2 -» copies hash     * keys(%hash) -» list of keys     * values(%hash) -» list of values     * while(($key, $value) = each(%hash))     * delete $hash{key} -» remove entry     * $hash{@keys} -» array of pairs   Regular Expressions Matching      * str =~ m/pat/ -» true if str matches pat     * str !~ m/pat/ -» true if str not matches     * $` -» before match     * $ -» matched     * $' -» after match     * m/pat/i -» ignore case     * m/pat/x -» ignore whitespace     * $str =~ m/pat/g -» array of matches     * m/$var/ -» contents of var   Substitution      * $str =~ s/pat/new/ -» replaces whatever matches pat with to new     * ex: "ab" =~ s/(\w)/$1:/g -» "a:b:"     * s/pat/new/g -» all occurrences     * s/pat/new/i -» ignores case     * can use match vars in replacement   Simple Patterns      * . -» any char except \n     * \d -» a digit     * \w -» alphanumeric or _     * \s -» whitespace     * \D -» not a digit     * \W -» not alphanumeric or _     * \S -» not whitespace     * [abc] -» a or b or c     * [a-z] -» any char from a thru z     * [^pat] -» chars not in pattern     * /blue|red|green/ -» choices     * /\Q$var\E/ -» disable special chars     * \Qpat\E -» disable special chars   Repeating Patterns      * c* -» zero or more c's     * c*? -» lazy * (as few as possible)     * c+ -» one or more c's     * c+? -» lazy +     * c? -» zero or one c     * c?? -» lazy ?     * c{3,7} -» between 3 and 7 c's     * c{3,} -» 3 or more c's     * c{3} -» exactly 3 c's     * c{3,7}? -» lazy   Extraction Patterns      * (pat) -» sets $1, $2, ...     * (?:pat) -» group without assigning   Anchor Patterns      * m/a/ -» 'a' anywhere in string     * m/^a/ -» 'a' at start of string     * m/a$/ -» 'a' at end of string     * \b -» word boundary     * \B -» not word boundary     * (?!a) -» must not match a     * (?=a) -» match but not consumed   Files File I/O      * $var = -» line from console     * @array = -» array of lines     * open(X, "file"); -» open for input     * open(X, ">file"); -» open for output     * open(X, ">>file"); -» open to append     * close(X); -» close file     * $! -» text of last system error     * $var = -» read line from handle     * $_ -» current line     * getc X -» read one char     * $/ = "x" -» set read delimiter     * print "text"; -» write to console     * print X "text"; -» write to handle     * print @array; -» print contents     * printf(format, var1, ...) -» like C++     * ex: %s, %d, %10.2f, %016x, %e     * sprintf(format, var1, ...) -» as string   File Attributes      * -f "file" -» true if file exists     * -d "dir" -» true if directory exists     * -w "file" -» true if file is writable     * -M "file" -» modification age in days     * -s "file" -» file size   File Management      * chdir "dir" -» change current dir     * @files = glob("*.cpp *.hpp") -» file list     * @files =   -» like glob     * opendir(X, "dir") -» files in dir     * closedir(X)     * readdir(X) -» next file (with . and ..)     * unlink("file") -» delete file     * unlink( ) -» delete matching     * rename("old", "new") -» rename file     * mkdir("dir") -» create dir     * rmdir("dir") -» delete empty dir     * chmod(0666, "file") -» set read/write     * chmod(0444, "file") -» set read only   Databases      * db is hash saved to disk     * dbmopen(%hash, "file", 0666) -» open     * dbmclose(%hash) -» close   General Flow Control      * { stmt1; stmt2; ... } -» block     * if (test1) {a} elsif (test2) {b} else {c}     * unless (test) {a} else {b}     * while (test) {block}     * until (test) {block}     * do {block} while (test)     * do {block} until (test)     * for (init;test; incr) {block}     * foreach $item (list) {block}     * last; -» exit loop or block     * redo; -» repeats loop or block     * next; -» continues enclosed loop     * LABEL: -» labels loop or block     * last LABEL; -» exit to label     * next LABEL; -» continues at label     * redo LABEL; -» repeats at label     * expr if test;     * expr unless test;     * expr while test;     * expr until test;     * expr1 and expr2;     * expr1 or expr2;     * not expr     * expr1 ? expr2 : expr3;     * die "msg\n"; -» prints and aborts     * warn "msg\n"; -» prints and continues     * grep {test} @arr -» subset     * ex: grep {$_ > 2} (1, 2, 3, 4) -» (3, 4)     * grep test, @arr -» subset     * ex: grep m/a/, ('cat', 'dog') -» ('cat')     * map {block} @arr -» apply block to arr     * ex: map {$_ * 2} (1, 2, 3) -» (2, 4, 6)     * map expr, @arr -» apply expr to arr     * ex: map m/(\w)/,('a1','b2') -» ('a','b')   Functions      * sub func {body} -» defune func     * sub func(arg1, ...); -» declare func     * return val; -» returns val     * return (1, 2, 3); -» returns array     * func(arg1, arg2, ...); -» call function     * @_ -» arguments to function     * my ($var1, $var2) = @_; -» get args   Process Management      * %ENV -» environment variables     * $ENV{"var"} -» get var     * $ENV{"var"} = "value" -» set var     * system("cmd") -» execute DOS command - returns 0 if worked     * system("cmd","arg1","arg2") -» fast     * @results = `cmd` -» run DOS cmd, returns console text as array     * open(X, "cmd|") -» cmd started in own thread - output of cmd accessed via X     * open(X, "cmd1 | cmd2 |") -» output of cmd1 piped to cmd2 and its output piped to X     * open(X, "|cmd") -» cmd started in own thread - input sent to cmd via X     * close(X) -» waits for cmd to end   Environment Settings      * assoc .pl=Perl     * ftype Perl=D:\perl\bin\perl.exe %1 %*     * set PATHEXT=%PATHEXT%;.PL   Miscellaneous      * # -» comment to end of line     * variable names made of a-z, A-Z, and _     * use strict; -» must declare vars     * my $var; -» declare scalar var     * my $var = 123; -» initialized     * my @var; -» declare array var     * my %var; -» declare hash var     * local $var; -» local to func     * @ARGV -» command line arguments     * $ENV{envVar} -» value of envir var     * eval($code) -» run Perl code     * if error, puts error in $@     * perl -p -i.bak -e "s/aa/bb/g" file -» applies Perl code to file
     

    
