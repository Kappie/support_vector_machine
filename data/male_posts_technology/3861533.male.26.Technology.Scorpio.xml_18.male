

    
       
      Hallvard Vassbotn shows in his  urlLink blog  how to, in Delphi, from only an interface,  urlLink retrieve the implementing object . Awesome! It's not a new solution, he put it on the usenet  urlLink in 2002 , but it was news to me.   I did already know of a way to do this (see later below), but Hallvards way is cleaner (and even more cool):    function  GetImplementingObject( const  AInterface: IInterface): TObject;   const    AddByte =  $04244483 ;   // opcode for ADD DWORD PTR [ESP+4], Shortint     AddLong =  $04244481 ;   // opcode for ADD DWORD PTR [ESP+4], Longint       type    PAdjustSelfThunk = ^TAdjustSelfThunk;    TAdjustSelfThunk =  packed record     case  AddInstruction: longint  of        AddByte: (AdjustmentByte: shortint);       AddLong: (AdjustmentLong: longint);    end ;    PInterfaceMT = ^TInterfaceMT;    TInterfaceMT =  packed record      QueryInterfaceThunk: PAdjustSelfThunk;    end ;    TInterfaceRef = ^PInterfaceMT;   var    QueryInterfaceThunk: PAdjustSelfThunk;  begin    Result := Pointer(AInterface);     if  (Assigned(Result))  then   try      QueryInterfaceThunk := TInterfaceRef(AInterface)^.QueryInterfaceThunk;      case  QueryInterfaceThunk.AddInstruction  of        AddByte: Inc(PChar(Result), QueryInterfaceThunk.AdjustmentByte);       AddLong: Inc(PChar(Result), QueryInterfaceThunk.AdjustmentLong);      else        Result :=  nil ;      end ;    except      Result :=  nil ;    end ;  end ;        Explaining the method, I'm quoting Hallvard from another  urlLink usenet post :  My hack relies on the fact that all interfaces inherit from IInterface, so the first method is always QueryInterface. QI is always stdcall, but you are free to implement it as a static, virtual or dynamic method.  Luckily, in all three cases the thunks have identical prologue code to adjust the self pointer on the stack. The adjustment constant can fit into a 1-byte shortint, or it might take an entire longint - this depends on the size of the parent class. So I check the two cases and pick up the correct Self-adjustment field.  In the general case, the compiler actually creates 12 slightly different kinds of thunks. There are tree dimensions: - Offset of Interface Method Table (IMT) in the object instance (shortint/longint) - Calling convention: stack-based ([ESP+4] for stdcall/cdecl/pascal/safecall) or register-based (EAX) - Static, virtual or dynamic (interfaces cannot declare message methods)  The thunks for virtual and dynamic register methods are particularly interesting, because the code cannot modify any registers...   The old way:    function  GetImplementingObject( const  AInstance: IUnknown;  const  AGUID: TGUID;  const  AImplClass: TClass): TObject;  var    LInterfaceEntry: PInterfaceEntry;  begin    Result :=  nil ;    if  (AImplClass =  nil )  or  (AInstance =  nil )  then   begin      Exit;    end ;    LInterfaceEntry := AImplClass.GetInterfaceEntry(AGUID);    if  (Assigned(LInterfaceEntry))  then   begin     if  (LInterfaceEntry^.IOffset >  0 )  then     begin        Result := TObject(Integer(AInstance) - LInterfaceEntry^.IOffset);      end ;    end ;  end ;       It does seem that my current blogger theme isn't quite cut out for posting source code...
      
