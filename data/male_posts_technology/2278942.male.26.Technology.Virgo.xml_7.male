

     
      An AppDomain was a concept created in .NET to provide isolation within the context of a worker process. In the case of IIS 5, a single worker process (aspnet_wp.exe) is maintained for  all web sites , except in the case of web gardens, which may have more. In the case of IIS 6, a worker process (w3wp.exe) is maintained for an  application pool . To improve performance, web sites share this worker process, with the separation provided by a  logical process  within the process called an AppDomain.    Using .NET Remoting components from an ASP.NET application or IIS Hosted remote object    ASP.NET uses an AppDomain for each ASP.NET web site. This AppDomain contains the Application, Cache and in-process Session objects for the site. The situation is not very different for .NET remoting objects hosted on IIS. It is very easy to concieve single-call objects hosted in IIS to be new object instances in a totally different AppDomain, whereas the case is not so.  Consider the case: You have a .NET remoting object hosted in IIS which accesses another object through remoting. A common error one would make would be to register a channel on each invocation of the hosted object. This is likely to throw up a " channel x already registered " exception.  ChannelServices.RegisterChannel()  throws a RemotingException with the above message since a channel with the same name would have already been registered in a previous call. A channel needs to be unique by name to be registered in an AppDomain. Since only one AppDomain exists for the web site, unless recycled, you should instead check if the channel already exists prior to registering the channel with   GetChannel() .  The situation is slightly more complicated in the case of ASP.NET. If you plan to use a .NET Remote component from an ASP.NET page, you must establish the remoting configuration for the client at application start, using the  Application_Start  event in the  global.asax  file. When using  RemotingConfiguration.Configure() , you also need to very careful about the location of the configuration file. The HttpRequest will only see the virtual directory, and NOT the absolute path. However this can be circumvented using the  HttpRequest.MapPath()  method to obtain the full path to the configuration path. A similar technique can be used to setup the remoting configuration for .NET remoting objects hosted in IIS (ie via a  global.asax )  The no of AppDomains an process can contain can easily be determined by using  enumappdomains  utility.    How IIS processes requests    Process creation can be of two types: Manual and Automatic. Managed Console and Windows Forms applications comprise the former type. The latter are more tricky to deal with and consist of: 1) Managed Windows Service applications 2) Enterprise Services (COM+ including Queued Components) 3) IIS/ASP.NET We shall deal with only (3)  ASP.NET/IIS exhibits on-demand startup. They are started only when a request comes in. A request comes in through HTTP.SYS and gets queued. A control message gets sent to the WAS (W3SVC) which spins up the worker process if it is not already running. The worker process (aspnet_wp.exe or w3wp.exe) contains the appdomain for the request which fetches the request from the queue and processes it. All future requests are then routed to the AppDomain via HTTP.SYS and worker process. There is one AppDomain per application as stated earlier. Process pooling is available for ASP.NET. A process from the pool is assigned to requests in a round robin fashion and then the remains for the lifetime of the connection. Thread pooling is also available. In case of long running threads, ASP.NET kills the thread to give other request a chance. The worker process contains a thread pool of 20 by default. Once the request queue starts filling up ASP.NET starts rejecting further requests.  If a long running work item is unavoidable, it is advisable to store them in a queue and let them be processed by an application hosted in Enterprise Services or Windows Services.  How then does ASP.NET permit debugging? ASP.NET has an orphan mode where processes aren't recycled! This mode is used for debugging.  A comparison between Windows Services, Enterprise Services and ASP.NET is due... :) I shall try and cover it later.    AppDomain Recycling    Sometimes it becomes necessary to recycle an ASP.NET AppDomain without killing the worker process (it would kill the other AppDomains). Even during development, changes to shared assemblies and or other files is not uncommon. Since the CLR binds to assemblies at application start time, updates to assemblies will go unnoticed. The config files however are monitored for changes. Changes to a web application's web.config file causes the AppDomain running that application to undergo recycling. Simply "touching" the web.config will have the desired effect without killing the worker process. The same can be achieved by "touching" machine.config. However in this case, all AppDomains in the worker process will be recycled. A note of caution: you will obviously loose all Application, Cache and Session information! 
     
    
