

	 
      Testing Java classes that have a main function (i.e. they're meant to be run from the command line) can be a bit tricky.  Most main functions print to the standard out and err streams and call  System.exit(1)  if something goes wrong.  In order to test the correct functionality of the method for all conditionals, the test method is going to have to read the output streams and prevent  System.exit  from ending the test itself.    The solutions given here are generalized for most main functions, but will work on other code that has  System.out ,  System.err , or  System.exit  calls.    Hopefully the code below is mostly self-explanitory.  The output streams are captured by calling the  System.setOut  and  System.setErr  methods.  The output to those streams are stored in ByteArrayOutputStreams which are easily converted into Strings by using the toString method.  You should usually test for both expecting and not expecting error and output.  If you know the exact error or output that is expected, or even a phrase or keyword, that should be tested for also.    The  System.exit  is handled by setting a restrictive security policy.  This can be done using Java's security.policy file (I think...), but it is more verbose and manipulatable to set the JVM's SecurityManager class. I create an anonymous inner class that overwrites the checkExit function and throws a  SecurityException  in every case.  I also reset the JVM's SecurityManager back to the original one after the test is done to prevent any unintentional side effects from the test method.          public class MainFunctionTest extends TestCase {    ByteArrayOutputStream out;    ByteArrayOutputStream err;      /**     * Sets up the fixture by creating System.out and System.err redirects.     * This method is called before a test is executed.     */    protected void setUp() throws Exception {      super.setUp();      out = new ByteArrayOutputStream();      System.setOut(new PrintStream(out));      err = new ByteArrayOutputStream();      System.setErr(new PrintStream(err));    }      public void testOut() {      String[] args = new String[]{"arg1"};      JBench.main(args);        // Expect nothing on the error stream, something on the output stream      assertTrue(err.toString().length() == 0);      assertTrue(out.toString().length() > 0);    }        public void testNoArgs() {      SecurityManager curSecurityManager = System.getSecurityManager();      System.setSecurityManager(          new java.lang.SecurityManager() {            public void checkExit(int code) {              throw new SecurityException();            }          });      try {        JBench.main(new String[]{});        fail();      } catch (SecurityException ex) {        /* expected */      } finally {        System.setSecurityManager(curSecurityManager);      }    }  }          Do not take the above code as a good example of a UnitTest class.  I left a lot of "good practices" out for the sake of brevity.    -----------------     Quick update on JBench.  The project has been dead for 2 years.  I contacted the original developer and he is currently working on .NET stuff and won't be updating JBench.  I'm working on refactoring it and adding a bunch of new features.  The HtmlReport feature is really cool.  It creates an HTML page with all the benchmark information, stats, and charts generated by  urlLink JFreeChart .  I'll have a longer update when I've finished it.   
    
