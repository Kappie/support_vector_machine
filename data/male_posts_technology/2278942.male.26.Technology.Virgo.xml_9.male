

     
      The technique I'd like to cover today is a technique used to perform loop unrolling. Loops are often a good candidate for optimization. Do while loops, while loops, for-next loops all have a fairly similar structure: the provide a body of code to be executed within the loop, often with code that is dependent on the loop cycle (ie dependent on the variable used as the counter for the loop), and start and end conditions for the loop. Loops which are candidates for the use of Duff's device, may have a body which may or may not depend on the counter variable.  Lets take an example: How would one write code that copies one chunk of data into another? Typically, this is how it would be written:     send(to, from, count) { do *to = *from++; while(--count>0); }     Let me ignore things such as bounds checking for the pointers, etc for now. (They are, however, extremely important) When the above piece of code gets translated into machine code, the body gets converted into a chunk of code, as does the condition checking and is followed by a JMP instruction. Typically, the JMP instruction, confuses the branch prediction logic in the processor, causes it to clear its instruction prefetch cache, and also, inhibit pipelining.  One very creative way of doing the same thing without the disadvantages listed above is the Duff's device:     send(to, from, count) { register n=(count+7)/8; switch(count%8){ case 0:do{*to = *from++; case 7:*to = *from++; case 6:*to = *from++; case 5:*to = *from++; case 4:*to = *from++; case 3:*to = *from++; case 2:*to = *from++; case 1:*to = *from++; } while(--n>0); } }    This is, in my opinion, a brilliant way to achieve optimization. It does not matter which coding language you use, some people use in their Javascript, others in C, the effect of the optimization is quite aparent.  Try and understand what the code does! The value of n does not have to be the ceiling of the count by 8, it may be by 4, or any other no for that matter. However the no of cases arising would be equivalent. Also, not that each of the case statements allow the call flow to fall through, rather than break. You can put almost any logic in each of the case bodies, it does not matter. It will of course lead to a little code expansion, but the trade-off will be quite favourable. 
     
    
